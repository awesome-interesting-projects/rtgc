m-x gud-gdb to switch *dedicated* window

c-x c-a c-b to set breakpoint at point line. Who changed this and why?

service sshd start
// to enable sshd at boot time
systemctl enable sshd.service


git clone https://github.com/wadehennessey/rtgc

git commit -m "blah"

git push

use #define _GNU_SOURCE for weird compile problems not seeing decls


gdb> info signals


use next instead of continue to switch to diff thread break points

Semaphores
------------
in alloc when out of memory:
sem_post(&gc_semaphore);
sem_wait(&gc_semaphore);	

in rtgc_loop:
sem_wait(&gc_semaphore);
full_gc();
sem_post(&gc_semaphore);
------------

# these go in .gdbinit
handle SIGUSR1 nostop
set non-stop on

>set non-stop on
>set non-stop off
>show non-stop
>interrupt     will stop the running thread
>break a.c:166 if (j == 1535)


other profilers
----------------
perf ./a
perf report


NEXT:
-----
Just put locking needed by SXallocate and SXwrite_barrier call chain in

Then try concurrent mutate and rtgc

add
wmctrl -r "emacs" -e 1,-1,-1,770,1010


Ideas
-------
try  partition bit vector for write barrier record?
each bit reperesents the start of a 32 byte segment of the partition
each 8 bytes (word) represents 64*32bytes = 2048 bytes of the partition
so bit vector is 1/256 the size of the entire partition, which
is about .4% overhead.

clear bit vector or recyling memory and write barrier is off
scan vector each time scan_gray_set runs out of gray object.
when gray runs out and scan vector produces no more gray, we're done
and can turn write barrier off recycle garbage, and clear bit vector.

will need a lock to set bit, there is no test and set BIT.
If we use a byte vector instead, then don't need a lock. Just test-and-set
a byte. However, then we'll need a byte vector that's 1/32 the size
of the partition. That's still only 3% overhead though.

Could try copy on write stacks on flip? no memcpy that way
would involve MAP_PRIVATE each stack to a file?



latest:

check if locking need in make_object_gray and
we set
group->black
group->free_last


write_barrier touches in make_object_gray:
group->white (rw)
group->gray (rw)
group->black (rw)
free_last (rw)
group->white_count

allocation touches:


CONFLICT:

allocate uses black and free_last on mutator thread
so does recycle garbage on gc thread
free_lock is held, but free_lock doesn't cover
  black and free_last

need a black_and_last_lock in:
1) new obj allocator (instead of locking make_object_gray)
2) make_object_gray (in addition to our make_object_gray lock)
3) recycle group garbage (a
