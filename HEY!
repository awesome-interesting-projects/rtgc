 m-x gud-gdb to switch *dedicated* window

c-x c-a c-b to set breakpoint at point line. Who changed this and why?

service sshd start
// to enable sshd at boot time
systemctl enable sshd.service


git clone https://github.com/wadehennessey/rtgc.git

git commit -m "blah"

git push

use #define _GNU_SOURCE for weird compile problems not seeing decls


gdb> info signals


use next instead of continue to switch to diff thread break points

Semaphores
------------
in alloc when out of memory:
sem_post(&gc_semaphore);
sem_wait(&gc_semaphore);	

in rtgc_loop:
sem_wait(&gc_semaphore);
full_gc();
sem_post(&gc_semaphore);
------------

# these go in .gdbinit
handle SIGUSR1 nostop
set non-stop on

>set non-stop on
>set non-stop off
>show non-stop
>interrupt     will stop the running thread
>break a.c:166 if (j == 1535)


other profilers
----------------
perf ./a
perf report


NEXT:
-----
Just put locking needed by SXallocate and SXwrite_barrier call chain in

Then try concurrent mutate and rtgc

add
wmctrl -r "emacs" -e 1,-1,-1,770,1010


Ideas
-------
try  partition bit vector for write barrier record?
each bit reperesents the start of a 32 byte segment of the partition
each 8 bytes (word) represents 64*32bytes = 2048 bytes of the partition
so bit vector is 1/256 the size of the entire partition, which
is about .4% overhead.

clear bit vector or recyling memory and write barrier is off
scan vector each time scan_gray_set runs out of gray object.
when gray runs out and scan vector produces no more gray, we're done
and can turn write barrier off recycle garbage, and clear bit vector.

will need a lock to set bit, there is no test and set BIT.
If we use a byte vector instead, then don't need a lock. Just test-and-set
a byte. However, then we'll need a byte vector that's 1/32 the size
of the partition. That's still only 3% overhead though.

Could try copy on write stacks on flip? no memcpy that way
would involve MAP_PRIVATE each stack to a file?



latest:

check if locking need in make_object_gray and
we set
group->black
group->free_last


write_barrier touches in make_object_gray:
group->white (rw)
group->gray (rw)
group->black (rw)
free_last (rw)
group->white_count


WHY:
group flip is sort of split between recycle garbage and flip.
locking all free locks in each phase first things to help reduce problems.
must be interaction we don't understand.

gdb> set unwindonsignal on


IDEA
POSSIBLE RACE - none now because of when gc holds free locks?
can setting storage_class in InitializeObject conflict with gc?
set storage class reads and then writes a the gchdr next pointer with new
storage class. Race if gc might be changing ptr at the same time

NO RACE
setting object color reads and writes the gcptr->next field. Maybe no race
here because gc colors free objects green while they are left over white
and nobody can reach them. Also, alloc does SET_COLOR while the within
the free_lock.

TODO:
-----
write new verify_group to be run on gc thread when all free locks are held.
Ok if write_barrier on or off - new write_vector allows this.

maybe verify on mutator thread if we SIGSTOP/SIGCONT the gc thread.

Run verify right after recycle_garbage has all free_locks

verify:
double linked lists correct - (obj->next)->prev == obj, (obj->prev)->next == obj
verify color in header and color in list are the same
verify all _count fields are correct.

TRY: ignoring group->*_count fields for now.
     page->bytes used doesn't matter until we add back coalescing

# to limit all threads in ./a to the second core:
taskset 0x10 ./a

# rr traces are stored in /home/wade/.local/share/rr/



gc end - gc_count 689000
gc end - gc_count 689500
gc end - gc_count 690000
a: rtalloc.c:243: init_pages_for_group: Assertion `((void *)0) != group->free' failed.
[rr.137493656] Warning: task 7599 (process 7598) dying from fatal signal SIGABRT.

real	185m4.775s
user	23m21.228s
sys	11m19.452s
[wade@mogmog rtgc]$ 


gdb tui mode in xterm: c-x a

too see event numbers and start at a specific event number:
rr -M replay -g <event-number>

first run take a long time
run again jumps to event time immediately on future runs


try gdb cmds:

checkpoint
info checkpoints
restart <cp-id>
delete <cp-id>

gdb "when" command shows current event-number

try rr -c and -e options to increase thread interleave

# task switch after every  retired branches
rr record -c 2500 ./a

# to see record options
rr record -h
rr replay -h

From rr/src/Scheduler.h
-c default:  enum { DEFAULT_MAX_TICKS = 250000 };    // 50ms time slice
-e default:  enum { DEFAULT_MAX_EVENTS = 10 };

new_word is allocated
0x7f46ba9f82d0
gcptr 0x7f46ba9f82c0

CONFUSING!!!!!
SXpointers = 0, but SC_POINTERS = 1
SXnopointer = 1 but SC_NOPOINTERS = 0


event time 630: new node alloc for "found" node thread switches to gc thread

stack location of "found", about to be copied into node word ptr
0x7f46b9f7ac48: 0x00007f46ba9f82d0

0x7f46b9 f7ae70: stack_bottom

0x7f46b9f7ac60: $rbp
less 0x18
0x7f46b9 f7ac48: 0x00007f46ba9f82d0


0x7f46b9f7ac30: $esp in live frame

0x7f46b9f7ab30: saved $esp seen in signal handler










0x7f46b9 77b000: stack base