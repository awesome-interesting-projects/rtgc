zm-x gud-gdb to switch *dedicated* window

c-x c-a c-b to set breakpoint at point line. Who changed this and why?

service sshd start
// to enable sshd at boot time
systemctl enable sshd.service


git clone https://github.com/wadehennessey/rtgc.git

git commit -am "blah"
# then must push commit
git push

use #define _GNU_SOURCE for weird compile problems not seeing decls


gdb> info signals
use next instead of continue to switch to diff thread break points

Semaphores
------------
in alloc when out of memory:
sem_post(&gc_semaphore);
sem_wait(&gc_semaphore);	

in rtgc_loop:
sem_wait(&gc_semaphore);
full_gc();
sem_post(&gc_semaphore);
------------

# these go in .gdbinit
handle SIGUSR1 nostop
set non-stop on

>set non-stop on
>set non-stop off
>show non-stop
>interrupt     will stop the running thread
>break a.c:166 if (j == 1535)


other profilers
----------------
perf ./a
perf report

add
wmctrl -r "emacs" -e 1,-1,-1,770,1010


Ideas
-------
Could try copy on write stacks on flip? no memcpy that way
would involve MAP_PRIVATE each stack to a file?

gdb> set unwindonsignal on


IDEA
POSSIBLE RACE - none now because of when gc holds free locks?
can setting storage_class in InitializeObject conflict with gc?
set storage class reads and then writes a the gchdr next pointer with new
storage class. Race if gc might be changing ptr at the same time

NO RACE
setting object color reads and writes the gcptr->next field. Maybe no race
here because gc colors free objects green while they are left over white
and nobody can reach them. Also, alloc does SET_COLOR while the within
the free_lock.

TODO:
-----
write new verify_group to be run on gc thread when all free locks are held.
Ok if write_barrier on or off - new write_vector allows this.

maybe verify on mutator thread if we SIGSTOP/SIGCONT the gc thread.

Run verify right after recycle_garbage has all free_locks

verify:
double linked lists correct - (obj->next)->prev == obj, (obj->prev)->next == obj
verify color in header and color in list are the same
verify all _count fields are correct.

# to limit all threads in ./a to the second core:
taskset 0x10 ./a

# rr traces are stored in /home/wade/.local/share/rr/

gdb tui mode in xterm: c-x a

too see event numbers and start at a specific event number:
rr -M replay -g <event-number>

first run take a long time
run again jumps to event time immediately on future runs


try gdb cmds:
-------------
checkpoint
info checkpoints - not implemented
restart <cp-id>
delete <cp-id>

gdb "when" command shows current event-number

try rr -c and -e options to increase thread interleave

# task switch after every N retired branches
rr record -c 2500 ./a

# I think I recorded "the bug" with this (compile "make debug")
rr record -c 5 ./a

# to see record options
rr record -h
rr replay -h

From rr/src/Scheduler.h
-c default:  enum { DEFAULT_MAX_TICKS = 250000 };    // 50ms time slice
-e default:  enum { DEFAULT_MAX_EVENTS = 10 };

To run real-time round-robin:
-----------------
chrt --rr 30 ./a
or
chrt --fifo 30 ./a

ps -Lo pid,tid,class <./a pid #>


To add swap
------------
su
cd /home
dd if=/dev/zero of=bigswapfile bs=1G count=64
chmod 600 /root/bigswapfile
mkswap bigswapfile
swapon bigswapfile

in /etc/fstab add:
/home/bigswapfile		swap		swap	defaults	0 0


cleanup
-------
200ns for the "null" signal and return time. Includes double the "system" time.
Mean 5000 "null" signal and returns per 1ms.

Time for 1,000,000 "null" kill signal and returns 
real	0m0.209s
user	0m0.029s
sys	0m0.389s


use struct timespec for nanosecond timing on handler 

support md
fix clearing of md after install

finish merge of init_metadata and init_body into RTallocate directly
HEY! for SXpointers, must init to 0 all of object body, not just actual size
don't init SXnopointers memory!
---------------------------------------------
break Debugger
break __assert

try gcc -mcmodel=large to avoid dlopen relocation problems in wcl

remove all uses of pages bytes_used field

split group->black_count into 2: 
black_count == black_scanned_count + black_new_count
remove black_count_lock with count_lock for conditional debugging 

change group->free_last to just group->last?